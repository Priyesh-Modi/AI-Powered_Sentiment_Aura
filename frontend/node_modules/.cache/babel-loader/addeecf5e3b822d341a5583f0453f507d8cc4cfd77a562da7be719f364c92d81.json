{"ast":null,"code":"var _jsxFileName = \"/Users/priyeshmodi/Downloads/sentiment-aura/frontend/src/components/AuraVisualization.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect } from 'react';\nimport p5 from 'p5';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst AuraVisualization = ({\n  sentiment,\n  energy,\n  emotion,\n  colorPalette,\n  keywords\n}) => {\n  _s();\n  const sketchRef = useRef();\n  const p5InstanceRef = useRef();\n  useEffect(() => {\n    // Create p5 sketch\n    const sketch = p => {\n      let time = 0;\n      let particles = [];\n      let flowField = [];\n      let cols, rows;\n      let zoff = 0;\n      let currentSentiment = 0;\n      let currentEnergy = 0.5;\n      let currentColors = ['#4A90E2', '#50C878', '#FFB347'];\n      let targetSentiment = 0;\n      let targetEnergy = 0.5;\n      let targetColors = ['#4A90E2', '#50C878', '#FFB347'];\n      let currentEmotion = 'neutral';\n      let currentKeywords = [];\n\n      // Particle class\n      class Particle {\n        constructor() {\n          this.pos = p.createVector(p.random(p.width), p.random(p.height));\n          this.vel = p.createVector(0, 0);\n          this.acc = p.createVector(0, 0);\n          this.maxSpeed = 2;\n          this.size = p.random(1, 4);\n          this.life = 255;\n          this.maxLife = 255;\n        }\n        update() {\n          this.vel.add(this.acc);\n          this.vel.limit(this.maxSpeed * (currentEnergy * 2 + 0.5));\n          this.pos.add(this.vel);\n          this.acc.mult(0);\n\n          // Age the particle\n          this.life -= p.random(0.5, 2);\n\n          // Wrap around edges\n          if (this.pos.x < 0) this.pos.x = p.width;\n          if (this.pos.x > p.width) this.pos.x = 0;\n          if (this.pos.y < 0) this.pos.y = p.height;\n          if (this.pos.y > p.height) this.pos.y = 0;\n        }\n        follow(flowField) {\n          let x = p.floor(this.pos.x / 20);\n          let y = p.floor(this.pos.y / 20);\n          let index = x + y * cols;\n          if (index >= 0 && index < flowField.length) {\n            let force = flowField[index].copy();\n            force.mult(0.5);\n            this.acc.add(force);\n          }\n        }\n        show() {\n          let alpha = p.map(this.life, 0, this.maxLife, 0, 100);\n          let colorIndex = p.floor(p.map(this.pos.x + this.pos.y, 0, p.width + p.height, 0, currentColors.length));\n          colorIndex = p.constrain(colorIndex, 0, currentColors.length - 1);\n          p.push();\n          p.translate(this.pos.x, this.pos.y);\n\n          // Create glow effect\n          for (let i = 0; i < 3; i++) {\n            p.fill(p.red(currentColors[colorIndex]), p.green(currentColors[colorIndex]), p.blue(currentColors[colorIndex]), alpha / (i + 1));\n            p.noStroke();\n            p.ellipse(0, 0, this.size * (3 - i), this.size * (3 - i));\n          }\n          p.pop();\n        }\n        isDead() {\n          return this.life <= 0;\n        }\n      }\n      p.setup = () => {\n        p.createCanvas(p.windowWidth, p.windowHeight);\n        p.colorMode(p.RGB);\n        p.background(0);\n        cols = p.floor(p.width / 20);\n        rows = p.floor(p.height / 20);\n        flowField = new Array(cols * rows);\n\n        // Initialize particles\n        for (let i = 0; i < 200; i++) {\n          particles.push(new Particle());\n        }\n      };\n      p.draw = () => {\n        // Smooth transitions\n        currentSentiment = p.lerp(currentSentiment, targetSentiment, 0.02);\n        currentEnergy = p.lerp(currentEnergy, targetEnergy, 0.02);\n\n        // Interpolate colors\n        for (let i = 0; i < currentColors.length; i++) {\n          if (i < targetColors.length) {\n            currentColors[i] = lerpColor(currentColors[i], targetColors[i], 0.02);\n          }\n        }\n\n        // Create dynamic background based on sentiment\n        let bgAlpha = p.map(Math.abs(currentSentiment), 0, 1, 5, 20);\n        p.fill(0, bgAlpha);\n        p.rect(0, 0, p.width, p.height);\n\n        // Update flow field based on Perlin noise and sentiment\n        let yoff = 0;\n        for (let y = 0; y < rows; y++) {\n          let xoff = 0;\n          for (let x = 0; x < cols; x++) {\n            let index = x + y * cols;\n\n            // Enhanced noise calculation with sentiment influence\n            let angle = p.noise(xoff, yoff, zoff) * p.TWO_PI * 2;\n            angle += currentSentiment * p.PI * 0.5; // Sentiment influences direction\n            angle += p.sin(time * 0.01 + x * 0.1) * currentEnergy; // Energy adds oscillation\n\n            flowField[index] = p5.Vector.fromAngle(angle);\n            flowField[index].mult(currentEnergy * 0.5 + 0.1);\n            xoff += 0.1;\n          }\n          yoff += 0.1;\n        }\n        zoff += 0.005 + currentEnergy * 0.01;\n\n        // Update and display particles\n        for (let i = particles.length - 1; i >= 0; i--) {\n          particles[i].follow(flowField);\n          particles[i].update();\n          particles[i].show();\n          if (particles[i].isDead()) {\n            particles.splice(i, 1);\n            particles.push(new Particle());\n          }\n        }\n\n        // Add emotion-based effects\n        drawEmotionEffects();\n\n        // Draw keyword bursts\n        drawKeywordBursts();\n        time++;\n      };\n      const drawEmotionEffects = () => {\n        p.push();\n        p.blendMode(p.SCREEN);\n        switch (currentEmotion) {\n          case 'joy':\n            // Bright bursts\n            for (let i = 0; i < 3; i++) {\n              let x = p.random(p.width);\n              let y = p.random(p.height);\n              let burstSize = p.random(50, 200) * currentEnergy;\n              p.fill(255, 255, 0, 10);\n              p.noStroke();\n              p.ellipse(x, y, burstSize);\n            }\n            break;\n          case 'anger':\n            // Sharp, angular effects\n            p.stroke(255, 100, 100, 50);\n            p.strokeWeight(2);\n            for (let i = 0; i < 10; i++) {\n              let x1 = p.random(p.width);\n              let y1 = p.random(p.height);\n              let x2 = x1 + p.random(-100, 100) * currentEnergy;\n              let y2 = y1 + p.random(-100, 100) * currentEnergy;\n              p.line(x1, y1, x2, y2);\n            }\n            break;\n          case 'sadness':\n            // Downward flowing particles\n            p.fill(100, 150, 255, 30);\n            p.noStroke();\n            for (let i = 0; i < 20; i++) {\n              let x = p.random(p.width);\n              let y = p.random(0, p.height * 0.3);\n              let dropY = y + p.sin(time * 0.1 + i) * 50;\n              p.ellipse(x, dropY, 3, 10 + currentEnergy * 10);\n            }\n            break;\n          case 'fear':\n            // Chaotic, scattered effects\n            p.stroke(200, 100, 200, 30);\n            p.strokeWeight(1);\n            for (let i = 0; i < 50; i++) {\n              let x = p.random(p.width);\n              let y = p.random(p.height);\n              let pointSize = p.random(5, 20) * currentEnergy;\n              let offset = p.noise(time * 0.05 + i) * 100;\n              p.point(x + offset, y + offset);\n              // Use pointSize for future enhancements\n              console.log(pointSize); // Temporary to avoid unused warning\n            }\n            break;\n          default:\n            // Neutral state - subtle ambient effects\n            p.fill(255, 255, 255, 5);\n            p.noStroke();\n            for (let i = 0; i < 5; i++) {\n              let x = p.random(p.width);\n              let y = p.random(p.height);\n              p.ellipse(x, y, 20 + currentEnergy * 10);\n            }\n            break;\n        }\n        p.pop();\n      };\n      const drawKeywordBursts = () => {\n        if (currentKeywords && currentKeywords.length > 0) {\n          p.push();\n          p.blendMode(p.ADD);\n          currentKeywords.forEach((keyword, index) => {\n            let angle = index / currentKeywords.length * p.TWO_PI;\n            let radius = 100 + p.sin(time * 0.02 + index) * 50;\n            let x = p.width / 2 + p.cos(angle) * radius;\n            let y = p.height / 2 + p.sin(angle) * radius;\n            p.fill(255, 255, 255, 20 + currentEnergy * 20);\n            p.noStroke();\n            p.ellipse(x, y, 30 + currentEnergy * 20);\n          });\n          p.pop();\n        }\n      };\n      const lerpColor = (c1, c2, t) => {\n        let color1 = p.color(c1);\n        let color2 = p.color(c2);\n        let r = p.lerp(p.red(color1), p.red(color2), t);\n        let g = p.lerp(p.green(color1), p.green(color2), t);\n        let b = p.lerp(p.blue(color1), p.blue(color2), t);\n        return p.color(r, g, b);\n      };\n      p.windowResized = () => {\n        p.resizeCanvas(p.windowWidth, p.windowHeight);\n        cols = p.floor(p.width / 20);\n        rows = p.floor(p.height / 20);\n        flowField = new Array(cols * rows);\n      };\n\n      // Update function to receive props\n      p.updateProps = (newSentiment, newEnergy, newEmotion, newColors, newKeywords) => {\n        targetSentiment = newSentiment || 0;\n        targetEnergy = newEnergy || 0.5;\n        currentEmotion = newEmotion || 'neutral';\n        targetColors = newColors || ['#4A90E2', '#50C878', '#FFB347'];\n        currentKeywords = newKeywords || [];\n      };\n    };\n\n    // Create p5 instance\n    p5InstanceRef.current = new p5(sketch, sketchRef.current);\n\n    // Cleanup function\n    return () => {\n      if (p5InstanceRef.current) {\n        p5InstanceRef.current.remove();\n      }\n    };\n  }, []); // Empty dependency array is correct here\n\n  // Update props when they change\n  useEffect(() => {\n    if (p5InstanceRef.current && p5InstanceRef.current.updateProps) {\n      p5InstanceRef.current.updateProps(sentiment, energy, emotion, colorPalette, keywords);\n    }\n  }, [sentiment, energy, emotion, colorPalette, keywords]); // All dependencies included\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: sketchRef,\n    className: \"aura-visualization\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 299,\n    columnNumber: 10\n  }, this);\n};\n_s(AuraVisualization, \"T2195x1OJvuMcJELuETZDlXX3AA=\");\n_c = AuraVisualization;\nexport default AuraVisualization;\nvar _c;\n$RefreshReg$(_c, \"AuraVisualization\");","map":{"version":3,"names":["React","useRef","useEffect","p5","jsxDEV","_jsxDEV","AuraVisualization","sentiment","energy","emotion","colorPalette","keywords","_s","sketchRef","p5InstanceRef","sketch","p","time","particles","flowField","cols","rows","zoff","currentSentiment","currentEnergy","currentColors","targetSentiment","targetEnergy","targetColors","currentEmotion","currentKeywords","Particle","constructor","pos","createVector","random","width","height","vel","acc","maxSpeed","size","life","maxLife","update","add","limit","mult","x","y","follow","floor","index","length","force","copy","show","alpha","map","colorIndex","constrain","push","translate","i","fill","red","green","blue","noStroke","ellipse","pop","isDead","setup","createCanvas","windowWidth","windowHeight","colorMode","RGB","background","Array","draw","lerp","lerpColor","bgAlpha","Math","abs","rect","yoff","xoff","angle","noise","TWO_PI","PI","sin","Vector","fromAngle","splice","drawEmotionEffects","drawKeywordBursts","blendMode","SCREEN","burstSize","stroke","strokeWeight","x1","y1","x2","y2","line","dropY","pointSize","offset","point","console","log","ADD","forEach","keyword","radius","cos","c1","c2","t","color1","color","color2","r","g","b","windowResized","resizeCanvas","updateProps","newSentiment","newEnergy","newEmotion","newColors","newKeywords","current","remove","ref","className","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/priyeshmodi/Downloads/sentiment-aura/frontend/src/components/AuraVisualization.js"],"sourcesContent":["import React, { useRef, useEffect } from 'react';\nimport p5 from 'p5';\n\nconst AuraVisualization = ({ sentiment, energy, emotion, colorPalette, keywords }) => {\n  const sketchRef = useRef();\n  const p5InstanceRef = useRef();\n\n  useEffect(() => {\n    // Create p5 sketch\n    const sketch = (p) => {\n      let time = 0;\n      let particles = [];\n      let flowField = [];\n      let cols, rows;\n      let zoff = 0;\n      let currentSentiment = 0;\n      let currentEnergy = 0.5;\n      let currentColors = ['#4A90E2', '#50C878', '#FFB347'];\n      let targetSentiment = 0;\n      let targetEnergy = 0.5;\n      let targetColors = ['#4A90E2', '#50C878', '#FFB347'];\n      let currentEmotion = 'neutral';\n      let currentKeywords = [];\n\n      // Particle class\n      class Particle {\n        constructor() {\n          this.pos = p.createVector(p.random(p.width), p.random(p.height));\n          this.vel = p.createVector(0, 0);\n          this.acc = p.createVector(0, 0);\n          this.maxSpeed = 2;\n          this.size = p.random(1, 4);\n          this.life = 255;\n          this.maxLife = 255;\n        }\n\n        update() {\n          this.vel.add(this.acc);\n          this.vel.limit(this.maxSpeed * (currentEnergy * 2 + 0.5));\n          this.pos.add(this.vel);\n          this.acc.mult(0);\n          \n          // Age the particle\n          this.life -= p.random(0.5, 2);\n          \n          // Wrap around edges\n          if (this.pos.x < 0) this.pos.x = p.width;\n          if (this.pos.x > p.width) this.pos.x = 0;\n          if (this.pos.y < 0) this.pos.y = p.height;\n          if (this.pos.y > p.height) this.pos.y = 0;\n        }\n\n        follow(flowField) {\n          let x = p.floor(this.pos.x / 20);\n          let y = p.floor(this.pos.y / 20);\n          let index = x + y * cols;\n          if (index >= 0 && index < flowField.length) {\n            let force = flowField[index].copy();\n            force.mult(0.5);\n            this.acc.add(force);\n          }\n        }\n\n        show() {\n          let alpha = p.map(this.life, 0, this.maxLife, 0, 100);\n          let colorIndex = p.floor(p.map(this.pos.x + this.pos.y, 0, p.width + p.height, 0, currentColors.length));\n          colorIndex = p.constrain(colorIndex, 0, currentColors.length - 1);\n          \n          p.push();\n          p.translate(this.pos.x, this.pos.y);\n          \n          // Create glow effect\n          for (let i = 0; i < 3; i++) {\n            p.fill(p.red(currentColors[colorIndex]), p.green(currentColors[colorIndex]), p.blue(currentColors[colorIndex]), alpha / (i + 1));\n            p.noStroke();\n            p.ellipse(0, 0, this.size * (3 - i), this.size * (3 - i));\n          }\n          \n          p.pop();\n        }\n\n        isDead() {\n          return this.life <= 0;\n        }\n      }\n\n      p.setup = () => {\n        p.createCanvas(p.windowWidth, p.windowHeight);\n        p.colorMode(p.RGB);\n        p.background(0);\n        \n        cols = p.floor(p.width / 20);\n        rows = p.floor(p.height / 20);\n        flowField = new Array(cols * rows);\n        \n        // Initialize particles\n        for (let i = 0; i < 200; i++) {\n          particles.push(new Particle());\n        }\n      };\n\n      p.draw = () => {\n        // Smooth transitions\n        currentSentiment = p.lerp(currentSentiment, targetSentiment, 0.02);\n        currentEnergy = p.lerp(currentEnergy, targetEnergy, 0.02);\n        \n        // Interpolate colors\n        for (let i = 0; i < currentColors.length; i++) {\n          if (i < targetColors.length) {\n            currentColors[i] = lerpColor(currentColors[i], targetColors[i], 0.02);\n          }\n        }\n\n        // Create dynamic background based on sentiment\n        let bgAlpha = p.map(Math.abs(currentSentiment), 0, 1, 5, 20);\n        p.fill(0, bgAlpha);\n        p.rect(0, 0, p.width, p.height);\n\n        // Update flow field based on Perlin noise and sentiment\n        let yoff = 0;\n        for (let y = 0; y < rows; y++) {\n          let xoff = 0;\n          for (let x = 0; x < cols; x++) {\n            let index = x + y * cols;\n            \n            // Enhanced noise calculation with sentiment influence\n            let angle = p.noise(xoff, yoff, zoff) * p.TWO_PI * 2;\n            angle += currentSentiment * p.PI * 0.5; // Sentiment influences direction\n            angle += p.sin(time * 0.01 + x * 0.1) * currentEnergy; // Energy adds oscillation\n            \n            flowField[index] = p5.Vector.fromAngle(angle);\n            flowField[index].mult(currentEnergy * 0.5 + 0.1);\n            \n            xoff += 0.1;\n          }\n          yoff += 0.1;\n        }\n        zoff += 0.005 + currentEnergy * 0.01;\n\n        // Update and display particles\n        for (let i = particles.length - 1; i >= 0; i--) {\n          particles[i].follow(flowField);\n          particles[i].update();\n          particles[i].show();\n\n          if (particles[i].isDead()) {\n            particles.splice(i, 1);\n            particles.push(new Particle());\n          }\n        }\n\n        // Add emotion-based effects\n        drawEmotionEffects();\n        \n        // Draw keyword bursts\n        drawKeywordBursts();\n        \n        time++;\n      };\n\n      const drawEmotionEffects = () => {\n        p.push();\n        p.blendMode(p.SCREEN);\n        \n        switch (currentEmotion) {\n          case 'joy':\n            // Bright bursts\n            for (let i = 0; i < 3; i++) {\n              let x = p.random(p.width);\n              let y = p.random(p.height);\n              let burstSize = p.random(50, 200) * currentEnergy;\n              p.fill(255, 255, 0, 10);\n              p.noStroke();\n              p.ellipse(x, y, burstSize);\n            }\n            break;\n            \n          case 'anger':\n            // Sharp, angular effects\n            p.stroke(255, 100, 100, 50);\n            p.strokeWeight(2);\n            for (let i = 0; i < 10; i++) {\n              let x1 = p.random(p.width);\n              let y1 = p.random(p.height);\n              let x2 = x1 + p.random(-100, 100) * currentEnergy;\n              let y2 = y1 + p.random(-100, 100) * currentEnergy;\n              p.line(x1, y1, x2, y2);\n            }\n            break;\n            \n          case 'sadness':\n            // Downward flowing particles\n            p.fill(100, 150, 255, 30);\n            p.noStroke();\n            for (let i = 0; i < 20; i++) {\n              let x = p.random(p.width);\n              let y = p.random(0, p.height * 0.3);\n              let dropY = y + p.sin(time * 0.1 + i) * 50;\n              p.ellipse(x, dropY, 3, 10 + currentEnergy * 10);\n            }\n            break;\n            \n          case 'fear':\n            // Chaotic, scattered effects\n            p.stroke(200, 100, 200, 30);\n            p.strokeWeight(1);\n            for (let i = 0; i < 50; i++) {\n              let x = p.random(p.width);\n              let y = p.random(p.height);\n              let pointSize = p.random(5, 20) * currentEnergy;\n              let offset = p.noise(time * 0.05 + i) * 100;\n              p.point(x + offset, y + offset);\n              // Use pointSize for future enhancements\n              console.log(pointSize); // Temporary to avoid unused warning\n            }\n            break;\n            \n          default:\n            // Neutral state - subtle ambient effects\n            p.fill(255, 255, 255, 5);\n            p.noStroke();\n            for (let i = 0; i < 5; i++) {\n              let x = p.random(p.width);\n              let y = p.random(p.height);\n              p.ellipse(x, y, 20 + currentEnergy * 10);\n            }\n            break;\n        }\n        \n        p.pop();\n      };\n\n      const drawKeywordBursts = () => {\n        if (currentKeywords && currentKeywords.length > 0) {\n          p.push();\n          p.blendMode(p.ADD);\n          \n          currentKeywords.forEach((keyword, index) => {\n            let angle = (index / currentKeywords.length) * p.TWO_PI;\n            let radius = 100 + p.sin(time * 0.02 + index) * 50;\n            let x = p.width / 2 + p.cos(angle) * radius;\n            let y = p.height / 2 + p.sin(angle) * radius;\n            \n            p.fill(255, 255, 255, 20 + currentEnergy * 20);\n            p.noStroke();\n            p.ellipse(x, y, 30 + currentEnergy * 20);\n          });\n          \n          p.pop();\n        }\n      };\n\n      const lerpColor = (c1, c2, t) => {\n        let color1 = p.color(c1);\n        let color2 = p.color(c2);\n        \n        let r = p.lerp(p.red(color1), p.red(color2), t);\n        let g = p.lerp(p.green(color1), p.green(color2), t);\n        let b = p.lerp(p.blue(color1), p.blue(color2), t);\n        \n        return p.color(r, g, b);\n      };\n\n      p.windowResized = () => {\n        p.resizeCanvas(p.windowWidth, p.windowHeight);\n        cols = p.floor(p.width / 20);\n        rows = p.floor(p.height / 20);\n        flowField = new Array(cols * rows);\n      };\n\n      // Update function to receive props\n      p.updateProps = (newSentiment, newEnergy, newEmotion, newColors, newKeywords) => {\n        targetSentiment = newSentiment || 0;\n        targetEnergy = newEnergy || 0.5;\n        currentEmotion = newEmotion || 'neutral';\n        targetColors = newColors || ['#4A90E2', '#50C878', '#FFB347'];\n        currentKeywords = newKeywords || [];\n      };\n    };\n\n    // Create p5 instance\n    p5InstanceRef.current = new p5(sketch, sketchRef.current);\n\n    // Cleanup function\n    return () => {\n      if (p5InstanceRef.current) {\n        p5InstanceRef.current.remove();\n      }\n    };\n  }, []); // Empty dependency array is correct here\n\n  // Update props when they change\n  useEffect(() => {\n    if (p5InstanceRef.current && p5InstanceRef.current.updateProps) {\n      p5InstanceRef.current.updateProps(sentiment, energy, emotion, colorPalette, keywords);\n    }\n  }, [sentiment, energy, emotion, colorPalette, keywords]); // All dependencies included\n\n  return <div ref={sketchRef} className=\"aura-visualization\" />;\n};\n\nexport default AuraVisualization;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}